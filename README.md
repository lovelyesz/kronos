## DockerFile
- FROM java:8
- VOLUME /tmp
- ADD statement-task-starter.tar.gz /

#Kronos设计方案
    Kronos是基于k8s-api的定时任务系统，开发人员需要对kubernetes和docker有基本的了解。
设计Kronos的初衷是为了能够调度管理任务，维护任务之间的依赖关系形成一个完整的工作流，并且能够针对个别任务做分片扩容。
那么使用K8S需要解决的问题如下：

1. 单个任务的横向扩容方案，就是怎么能够将一个任务拆分成n个小任务同时执行，k8s中能够实现这种扩展的方案有很多，需要一个一个的判断甄别
2. 维护Job之间的依赖关系，比如：JobB必须要在JobA执行完成后才能执行，k8s中Job组件是没有关停开关的，创建后就开始执行
3. 任务流的刹车方案，上边说过k8s中job是没有关停开关的，那如何完成手动的快速停止一个工作流
接下来我们就针对上述问题描述一下实现方案
### 任务的横向扩容
需要了解k8s中的基本概念，Job，Pod，container这三者之间的关系简单的说一个Job中可以并行生成多个Pod，Pod数量取决于你设置的值和资源，一个Pod中有可以创建多个container这个container可以理解为docker的容器，这中三级结构就给我们提供的多种方案去实现任务的横向扩展
1. 一个job，一个pod，多个container
container之间无法并行执行，并且当资源不足时，这个job就不会执行，比如：有10个container每个执行需要1G内存，但是你的k8s集群只有8G内存，这时job就会一直停留等待资源
2. 一个job，多个pod，一个container
可以通过Job中的参数控制并行的Pod数量和创建了多少个Pod后Job停止，当资源不足时Pod的并行数量也会随之减少
3. 多个job，一个pod，一个container
Job无法并行执行，显然与我们的需求不符

经过测试决定使用第二种方案，一个job多个pod方式，pod中使用的docker容器镜像是一个，容器的执行命令又是在声明Job时就设置好的，所以还需要一个队列，队列中存放带有0～n的索引的信息，pod启动后去队列中取出一个信息来区分每个pod的不同
### Job之间的依赖关系
工作流中任务与任务之间需要有执行的先后顺序，而且要考虑到任务分片后对依赖关系的影响，比如：任务A的第1，2，3...n个pod执行完后任务B开始执行，这种依赖触发的方式k8s是没有现成的方案的，所以需要我们自己实现，第一时间我想到的计数触发CountDownLatch做个同步器，这个显然是需要多个docker容器之间的计数，所以这里使用了redisson中的CountDownLatch，原理这里就不多做赘述了

那么该由谁取countDown呢？pod执行完成后？经过实验发现pod执行过程中会经常遇到各种个样的问题导致程序无法执行到最后；我们利用了kubernetes的watch-list功能监控Job的状态来触发这个同步器
### 任务流的刹车
任务流在触发后往往会因为各种原因需要手动的关停，k8s中是没有Job停止的功能的只有创建和删除，经过测试删除Job后这个Job中声明的Pod不会立即停止，还会继续执行占用资源，同时还会影响到执行信息的溯源，所以我们采用了比较温和的方案，清空上述存放索引的任务队列，pod获取不对索引立即结束进程不再执行业务代码释放资源
